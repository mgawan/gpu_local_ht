1d0
< #include "hip/hip_runtime.h"
4,15c3
< #include <hip/hip_cooperative_groups.h>
< using namespace cooperative_groups;
< namespace cg = cooperative_groups;
< 
< /* This function required some changes for compatibility
<  * with the HIP library.  Synchronous shuffle functions do not
<  * currently exist in HIP.  The functionality should be the same
<  * as HIP wavefronts execute in lockstep, so as long as all
<  * threads execute this function it should have the same
<  * functionality.  That said, the functionality may not *strictly*
<  * be identical.
<  */
---
> 
21,25c9,11
<     // This function does not exist in HIP
<     //value = __shfl_sync(0xffffffff, value, 0);   // Synchronize all threads in warp, and get "value" from lane 0
<     value = __shfl(value, 0);   // Get "value" from lane 0
<     //if (value != arg && laneId == 0)
<     //    printf("Thread %d failed. with val:%d, arg:%d \n", threadIdx.x, value, arg);
---
>     value = __shfl_sync(0xffffffff, value, 0);   // Synchronize all threads in warp, and get "value" from lane 0
>     if (value != arg && laneId == 0)
>         printf("Thread %d failed. with val:%d, arg:%d \n", threadIdx.x, value, arg);
31c17
<   /*for(int i = 0; i < mer.length; i++){
---
>     for(int i = 0; i < mer.length; i++){
34c20
<     printf("\n");*/
---
>     printf("\n");
239c225
<         /*if(hash_val == orig_hash){ // loop till you reach the same starting positions and then return error
---
>         if(hash_val == orig_hash){ // loop till you reach the same starting positions and then return error
244c230
<         }*/
---
>         }
264c250
<         /*if(hash_val == orig_hash){ // loop till you reach the same starting positions and then return error
---
>         if(hash_val == orig_hash){ // loop till you reach the same starting positions and then return error
269c255
<         }*/
---
>         }
274,282d259
< /* This function required some significant changes due to lack
<  * of support for certain functions in the HIP library.  The
<  * __match_any_sync, __activemask, and __syncwarp functions do
<  * not exist within HIP.  As such, the intended thread divergent
<  * and selective synchronization behavior is not possible with
<  * the current implementation.  Any access to this function as
<  * it currently stands should be assumed to contain all of the
<  * threads in the warp operating in lock step.
<  */
287,288d263
<     int done = 0;
<     int prev;
291,317c266,271
<         if(__all(done))
<             return thread_ht[hash_val];
< 
<         if(!done) {
<             prev = atomicCAS(&thread_ht[hash_val].key.length, EMPTY, kmer_key.length);
< 
<             // This function doesn't exist in HIP
<             //int mask = __match_any_sync(__activemask(), (unsigned long long)&thread_ht[hash_val]); // all the threads in the warp which have same address
<             
<             if(prev == EMPTY){
<                 thread_ht[hash_val].key.start_ptr = kmer_key.start_ptr;
<                 thread_ht[hash_val].val = {.hi_q_exts = {0}, .low_q_exts = {0}, .ext = 0, .count = 0};
<             }
<         }
< 
<         // This function doesn't exist in HIP
<         //__syncwarp(mask);
< 
<         if(!done) {
<             if(prev != EMPTY && thread_ht[hash_val].key == kmer_key){
<                 //printf("key found, returning\n");// keep this for debugging
<                 done = 1;
<                 //return thread_ht[hash_val];
<             }else if (prev == EMPTY){
<                 done = 1;
<                 //return thread_ht[hash_val];
<             }
---
>         int prev = atomicCAS(&thread_ht[hash_val].key.length, EMPTY, kmer_key.length);
>         int mask = __match_any_sync(__activemask(), (unsigned long long)&thread_ht[hash_val]); // all the threads in the warp which have same address
>         
>         if(prev == EMPTY){
>             thread_ht[hash_val].key.start_ptr = kmer_key.start_ptr;
>             thread_ht[hash_val].val = {.hi_q_exts = {0}, .low_q_exts = {0}, .ext = 0, .count = 0};
319c273,275
<         if(__all(done))
---
>         __syncwarp(mask);
>         if(prev != EMPTY && thread_ht[hash_val].key == kmer_key){
>             //printf("key found, returning\n");// keep this for debugging
321,328c277,284
<         if(!done) {
<             hash_val = (hash_val + 1) % max_size;//hash_val = (hash_val + 1) & (HT_SIZE -1);
<             if(hash_val == orig_hash){ // loop till you reach the same starting positions and then return error
<                 printf("*****end reached, hashtable full*****\n"); // for debugging
<                 printf("*****end reached, hashtable full*****\n");
<                 printf("*****end reached, hashtable full*****\n");
<                 done = 1; // We will return the current hash for now (though incorrect)
<             }
---
>         }else if (prev == EMPTY){
>             return thread_ht[hash_val];
>         }
>         hash_val = (hash_val +1 ) %max_size;//hash_val = (hash_val + 1) & (HT_SIZE -1);
>         if(hash_val == orig_hash){ // loop till you reach the same starting positions and then return error
>             printf("*****end reached, hashtable full*****\n"); // for debugging
>             printf("*****end reached, hashtable full*****\n");
>             printf("*****end reached, hashtable full*****\n");
331d286
< }
332a288
> }
411c367
<     const int lane_id = threadIdx.x%WARP_SIZE;
---
>     const int lane_id = threadIdx.x%32;
416,421c372
<     int test = 1;
< 
<     //if(idx == 1 && threadIdx.x%WARP_SIZE == 0)
<     //    to_print = true;
<     int tid = threadIdx.x;
<     int bid = blockIdx.x;
---
>     // int test = 1;
422a374
>     //     printf("inside_count_mers, hash size:%d \n", max_ht_size);
427c379
<         //if(idx == test)
---
>         //     printf("read loop iter:%d, thread:%d, loop max:%d\n",i, threadIdx.x, r_rds_cnt);
437c389
<                 //if(idx == test)
---
>                 //     printf("rds_count_r_sum[idx]:%d, rds_cnt:%d, read_length:%d, thread_id:%d\n",rds_count_r_sum[idx], r_rds_cnt, read.length, threadIdx.x);
439c391
<             }
---
>                 }
441,442c393,394
<                 //printf("idx:%d, r_rdsx_cnt: %d, i: %d \n", idx, r_rds_cnt, i); 
<                 //printf("i:%d, rds_count:%d, idx:%d, thread:%d, blk:%d\n", i, r_rds_cnt, idx, tid, bid); 
---
>                 // printf("idx:%d, r_rdsx_cnt: %d, i: %d \n", idx, r_rds_cnt, i); 
>                 // printf("i:%d, rds_count:%d, idx:%d, thread:%d, blk:%d\n", i, r_rds_cnt, idx, threadIdx.x, blockIdx.x); 
445c397
<                 //if(idx == test)
---
>                 //     printf("rds_count_r_sum[idx]:%d,rds_count_r_sum[idx-1]:%d,i:%d, rds_cnt:%d, reads_offset_0:%d, thread:%d\n",rds_count_r_sum[idx], rds_count_r_sum[idx-1],i, r_rds_cnt, read.length, threadIdx.x);
453c405
<                 }
---
>                  }
461c413
<             //if(idx == test)
---
>             //      printf("rds_count_r_sum[idx]:%d, rds_cnt:%d, reads_offset_0:%d, thread:%d\n",rds_count_r_sum[idx], r_rds_cnt, read.length, threadIdx.x);
463,464c415,416
<             
<         }
---
>                 
>             }
467c419,422
<         //if(idx == test){
---
>         //     printf("mer_len:%d, read_len:%d\n",mer_len, read.length);
>         //     printf("read from idx:%d, thread:%d\n", idx, threadIdx.x);
>         //     print_mer(read);
>         //   }
472,473c427
< 
<         for( int start = lane_id; start < num_mers; start+=WARP_SIZE){
---
>         for( int start = lane_id; start < num_mers; start+=32){
476d429
< 
478c431
<                     
---
>             
480,482c433,435
<             //  assert(ext_pos < (int)read.length); // TODO: verify that assert works on gpu, for now commenting it out and replacing with printf
<             if(ext_pos >= (int) read.length)
<                 printf("*********ASSERTION FAILURE IN COUNT_MERS****");
---
>           //  assert(ext_pos < (int)read.length); // TODO: verify that assert works on gpu, for now commenting it out and replacing with printf
>           if(ext_pos >= (int) read.length)
>             printf("*********ASSERTION FAILURE IN COUNT_MERS****");
487a441,442
> 
>             //temp_Mer.val.set_ext(loc_ctg_depth);
489,495c444,448
<         // This function does not exist in HIP
<         //__syncwarp();
<         running_sum_len += read.length; // right before the for loop ends, update the prev_len to offset next read correctly
<     }
<     // This function does not exist in HIP
<     //__syncwarp();
<     for(auto k = lane_id; k < max_ht_size; k+=WARP_SIZE){
---
>         __syncwarp();
>        running_sum_len += read.length; // right before the for loop ends, update the prev_len to offset next read correctly
>     }
>     __syncwarp();
>     for(auto k = lane_id; k < max_ht_size; k+=32){
500,503c453,455
<     // This function does not exist in HIP
<     //__syncwarp();
<     //int test = 1;
< #ifdef DEBUG_PRINT_GPU
---
>     __syncwarp();
>     int test = 1;
>     #ifdef DEBUG_PRINT_GPU
507c459
<                 //{
---
>             //{
509,513c461,465
<                     printf("from ht:\n");
<                     print_mer(thrd_loc_ht[k].key);
<                     printf("MerFreq.ext:%c, MerFreq.count:%d\n",thrd_loc_ht[k].val.ext,thrd_loc_ht[k].val.count);
<                     thrd_loc_ht[k].val.hi_q_exts.print();
<                     thrd_loc_ht[k].val.low_q_exts.print();
---
>                 printf("from ht:\n");
>                 print_mer(thrd_loc_ht[k].key);
>                 printf("MerFreq.ext:%c, MerFreq.count:%d\n",thrd_loc_ht[k].val.ext,thrd_loc_ht[k].val.count);
>                 thrd_loc_ht[k].val.hi_q_exts.print();
>                 thrd_loc_ht[k].val.low_q_exts.print();
515c467
<                 //}
---
>             //}
519,717c471
<     // This function does not exist in HIP
<     //__syncwarp();
<     // This function does not exist in HIP
<     //__syncthreads();
< }
< 
< //same kernel will be used for right and left walks
< __global__ void iterative_walks_kernel(uint32_t* cid, uint32_t* ctg_offsets, char* contigs, char* reads_r, char* quals_r,  uint32_t* reads_r_offset,  uint32_t* rds_count_r_sum, 
< double* ctg_depth, loc_ht* global_ht,  uint32_t* prefix_ht, loc_ht_bool* global_ht_bool, int kmer_len, uint32_t max_mer_len_off, uint32_t *term_counts, int64_t num_walks, int64_t max_walk_len, 
< int64_t sum_ext, int32_t max_read_size, int32_t max_read_count, uint32_t qual_offset, char* longest_walks, char* mer_walk_temp, uint32_t* final_walk_lens, int tot_ctgs)
< {
<     const long int idx = threadIdx.x + blockIdx.x * blockDim.x;
<     const long int warp_id_glb = idx/WARP_SIZE;
<     const long int lane_id = threadIdx.x%WARP_SIZE;
<     //const long int warp_id_glb = idx/32;
<     //const long int lane_id = threadIdx.x%32;
<     if(warp_id_glb < tot_ctgs){ // so that no out of bound accesses 
<         cstr_type loc_ctg;
<         char *loc_r_reads, *loc_r_quals;
<         uint32_t r_rds_cnt;
<         loc_ht* loc_mer_map;
<         uint32_t ht_loc_size;
<         loc_ht_bool* loc_bool_map;
<         double loc_ctg_depth;
<         int64_t excess_reads;
<         uint32_t max_ht_size = 0;
<         char* longest_walk_loc;
<         char* loc_mer_walk_temp;
< #ifdef DEBUG_PRINT_GPU
<         int test = 1;
< #endif
< 
<         int min_mer_len = LASSM_MIN_KMER_LEN;
<         int max_mer_len = LASSM_MAX_KMER_LEN;
< 
<         int active = 1;
<     
<         //the warp portion is for HT phase only so mapping only reads related data based on warp id
<         if(warp_id_glb == 0){
<             loc_ctg.start_ptr = contigs;
<             loc_ctg.length = ctg_offsets[warp_id_glb];
<             loc_bool_map = global_ht_bool + warp_id_glb * max_walk_len;
<             longest_walk_loc = longest_walks + warp_id_glb * max_walk_len;
<             loc_mer_walk_temp = mer_walk_temp + warp_id_glb * (max_walk_len + max_mer_len_off);
<             r_rds_cnt = rds_count_r_sum[warp_id_glb];
<             loc_r_reads = reads_r;
<             loc_r_quals = quals_r;
<             loc_mer_map = global_ht;
<             ht_loc_size = prefix_ht[warp_id_glb];
<             loc_ctg_depth = ctg_depth[warp_id_glb];
<         }else{
<             loc_ctg.start_ptr = contigs + ctg_offsets[warp_id_glb-1];
<             loc_ctg.length = ctg_offsets[warp_id_glb] - ctg_offsets[warp_id_glb - 1];
<             loc_bool_map = global_ht_bool + warp_id_glb * max_walk_len;
<             longest_walk_loc = longest_walks + warp_id_glb * max_walk_len;
<             loc_mer_walk_temp = mer_walk_temp + warp_id_glb * (max_walk_len + max_mer_len_off);
<             loc_ctg_depth = ctg_depth[warp_id_glb];
<             r_rds_cnt = rds_count_r_sum[warp_id_glb] - rds_count_r_sum[warp_id_glb - 1];
<             if (rds_count_r_sum[warp_id_glb - 1] == 0)
<                 loc_r_reads = reads_r;
<             else
<                 loc_r_reads = reads_r + reads_r_offset[rds_count_r_sum[warp_id_glb - 1] - 1]; // you want to start from where previous contigs, last read ends.
< 
<             if (rds_count_r_sum[warp_id_glb - 1] == 0)
<                 loc_r_quals = quals_r;
<             else
<                 loc_r_quals = quals_r + reads_r_offset[rds_count_r_sum[warp_id_glb - 1] - 1]; // you want to start from where previous contigs, last read ends.
<        
<             loc_mer_map = global_ht + prefix_ht[warp_id_glb - 1];
<             ht_loc_size = prefix_ht[warp_id_glb] - prefix_ht[warp_id_glb - 1];
<         }
< 
<         max_ht_size = ht_loc_size;
<         max_mer_len = min(max_mer_len, loc_ctg.length);
< 
<         cstr_type longest_walk_thread(longest_walk_loc,0);
< 
<         //main for loop
<         int shift = 0;
< 
<         for(int mer_len = kmer_len; mer_len >= min_mer_len && mer_len <= max_mer_len; mer_len += shift){
<             // #ifdef DEBUG_PRINT_GPU
<             // if(warp_id_glb == test){
<             //    printf("GPU: shift:%d, mer_len:%d, min_mer_len:%d, idx:%d, max_mer_len:%d \n", shift, mer_len, min_mer_len, threadIdx.x, max_mer_len);
<             //    printf("contig:\n");
<             //    print_mer(loc_ctg);
<             //    }
<             // #endif
< 
<             if(warp_id_glb < tot_ctgs){ // all warps within this range can go in execute count mers, for walk_mers only the lane 0 of each warp does the work
<                 for(uint32_t k = lane_id; k < max_ht_size; k+=WARP_SIZE){ // resetting hash table in parallel with warps
<                     loc_mer_map[k].key.length = EMPTY;
<                 }
<                 count_mers(loc_mer_map, loc_r_reads, max_ht_size, loc_r_quals, reads_r_offset, r_rds_cnt, rds_count_r_sum, loc_ctg_depth, mer_len, qual_offset, excess_reads, warp_id_glb);//passing warp_id instead of idx now
<                 for(uint32_t k = lane_id; k < max_walk_len; k+=WARP_SIZE){ // resetting bool map for next go
<                     loc_bool_map[k].key.length = EMPTY;
<                 }
<                 if(lane_id == 0){ // this phase is processed by single thread of a warp
<                     cstr_type ctg_mer(loc_ctg.start_ptr + (loc_ctg.length - mer_len), mer_len);
<                     cstr_type loc_mer_walk(loc_mer_walk_temp, 0);
<                     cstr_copy(loc_mer_walk, ctg_mer);
<                     cstr_type walk(loc_mer_walk.start_ptr + mer_len, 0);
< 
<                     // #ifdef DEBUG_PRINT_GPU
<                     // if(warp_id_glb == test){
<                     //     printf("read_count:%d, idx:%d\n",r_rds_cnt, warp_id_glb);
<                     //     printf("mer ctg len:%d mer_walk before:\n",loc_mer_walk.length);
<                     //     print_mer(loc_mer_walk);
< 
<                     //    printf("ctg mer:\n");
<                     //    print_mer(ctg_mer);
<                     // }
<                     // #endif
< 
<                     char walk_res = walk_mers(loc_mer_map, loc_bool_map, max_ht_size, mer_len, loc_mer_walk, longest_walk_thread, walk, warp_id_glb, max_walk_len);
<                     // #ifdef DEBUG_PRINT_GPU
<                     // if(warp_id_glb == test){
<                     //     printf("walk_res:%c, idx:%d\n",walk_res, warp_id_glb);
<                     //     printf("GPU: walk.len:%d, longest.len:%d, idx:%d\n", walk.length, longest_walk_thread.length, warp_id_glb);
<                     // }
<                     // #endif
<                     //int walk_len = walk.length
<                     if (walk.length > longest_walk_thread.length){ // this walk is longer than longest then copy it to longest walk
<                         cstr_copy(longest_walk_thread, walk);
<                     }
<                     if (walk_res == 'X') {
<                         // atomicAdd(&term_counts[0], 1);
<                         // walk reaches a dead-end, downshift, unless we were upshifting
<                         if (shift == LASSM_SHIFT_SIZE) {
<                             active = 0;
<                             goto end;
<                             //break;
<                         }
<                         shift = -LASSM_SHIFT_SIZE;
<                     }else {
<                         //if (walk_res == 'F') 
<                         // atomicAdd(&term_counts[1], 1);
<                         //else 
<                         //atomicAdd(&term_counts[2], 1);
<                         // otherwise walk must end with a fork or repeat, so upshift
<                         if (shift == -LASSM_SHIFT_SIZE){
<                             // #ifdef DEBUG_PRINT_GPU
<                             // printf("breaking at shift neg:%d\n", shift);
<                             // #endif
<                             active = 0;
<                             goto end;
<                             //break;
<                         }
<                         if (mer_len > loc_ctg.length){
<                             // #ifdef DEBUG_PRINT_GPU
<                             // printf("breaking at mer_len too large:%d\n", mer_len);
<                             // #endif
<                             active = 0;
<                             goto end;
<                             //break;
<                         }
<                         shift = LASSM_SHIFT_SIZE;
<                     }
< 
<                 }// lane id cond ended
<                 end:
<                 // This function does not exist in HIP
<                 //__syncwarp(FULL_MASK);
<                 /*
<                 // This function does not exist in HIP
<                 unsigned mask = __activemask();
<                 unsigned active = mask & 1; // zero if lane 0 has returned
<                 */
<                 active = bcast_warp(active);
<                 if(active == 0)
<                     break; // return if lane 0 has returned
<                 shift = bcast_warp(shift);
<             }//warp id cond end
< 
<         }
<         if(lane_id == 0){
<             if(longest_walk_thread.length > 0){
<                 final_walk_lens[warp_id_glb] = longest_walk_thread.length;
<                 // printf("final longest walk len:%d/n", longest_walk_thread.length);
<                 // print_mer(longest_walk_thread);
<                 // atomicAdd(num_walks, 1);
<                 //   atomicAdd(sum_ext, longest_walk_thread.length);
<             }else{
<                 final_walk_lens[warp_id_glb] = 0;
<             }
<         }
< 
< #ifdef DEBUG_PRINT_GPU
<         if(idx == test){
<             // printf("walk:\n");
<             // print_mer(walk);
<             // printf("walk len:%d\n", walk.length);
<             // printf("mer_walk after:\n");
<             // print_mer(loc_mer_walk);
<             // printf("mer_walk after, len:%d\n", loc_mer_walk.length);
<         }
<         //printf("walk result:%c\n", walk_res);
< #endif
<     }//end if to check if idx exceeds contigs
---
>     __syncwarp();
719,723d472
< 
< //////////////////////////////////////////
< ///////////// Broken /////////////////////
< //////////////////////////////////////////
< #if 0
730,731c479,480
<     const long int warp_id_glb = idx/WARP_SIZE;
<     const long int lane_id = threadIdx.x%WARP_SIZE;
---
>     const long int warp_id_glb = idx/32;
>     const long int lane_id = threadIdx.x%32;
747d495
<     int active = 1;
751d498
< 
796d542
<     int test = 1;
799,804c545,549
<              if(warp_id_glb == test){
<                  int tid = threadIdx.x;
<                  //printf("GPU: shift:%d, mer_len:%d, min_mer_len:%d, idx:%d, max_mer_len:%d \n", shift, mer_len, min_mer_len, tid, max_mer_len);
<                  //printf("contig:\n");
<                  //print_mer(loc_ctg);
<                 }
---
>             // if(warp_id_glb == test){
>             //    printf("GPU: shift:%d, mer_len:%d, min_mer_len:%d, idx:%d, max_mer_len:%d \n", shift, mer_len, min_mer_len, threadIdx.x, max_mer_len);
>             //    printf("contig:\n");
>             //    print_mer(loc_ctg);
>             //    }
808c553
<             for(uint32_t k = lane_id; k < max_ht_size; k+=WARP_SIZE){ // resetting hash table in parallel with warps
---
>             for(uint32_t k = lane_id; k < max_ht_size; k+=32){ // resetting hash table in parallel with warps
812c557
<             for(uint32_t k = lane_id; k < max_walk_len; k+=WARP_SIZE){ // resetting bool map for next go
---
>             for(uint32_t k = lane_id; k < max_walk_len; k+=32){ // resetting bool map for next go
844c589
<                 // atomicAdd(&term_counts[0], 1);
---
>                // atomicAdd(&term_counts[0], 1);
846,848c591
<                 if (shift == LASSM_SHIFT_SIZE) {
<                     active = 0;
<                     goto end;
---
>                 if (shift == LASSM_SHIFT_SIZE) 
850d592
<                 }
854c596
<                 // atomicAdd(&term_counts[1], 1);
---
>                    // atomicAdd(&term_counts[1], 1);
856c598
<                 //atomicAdd(&term_counts[2], 1);
---
>                     //atomicAdd(&term_counts[2], 1);
862,863d603
<                     active = 0;
<                     goto end;
865c605
<                 }
---
>                     }
868c608
<                     //printf("breaking at mer_len too large:%d\n", mer_len);
---
>                     // printf("breaking at mer_len too large:%d\n", mer_len);
870,871d609
<                     active = 0;
<                     goto end;
878,882c616,618
< 	end:
<         // This function does not exist in HIP
<         //__syncwarp(FULL_MASK);
<         //printf("synchronization...\n");
<         active = bcast_warp(active);
---
>         __syncwarp(FULL_MASK);
>         unsigned mask = __activemask();
>         unsigned active = mask & 1; // zero if lane 0 has returned
884,890c620
<             break;
<         //__syncthreads();
<         // This function does not exist in HIP
<         //unsigned mask = __activemask();
<         //unsigned active = mask & 1; // zero if lane 0 has returned
<         //if(active == 0)
<         //    break; // return if lane 0 has returned
---
>             break; // return if lane 0 has returned
892,893c622
<         __syncthreads();
<     }//warp id cond end
---
>         }//warp id cond end
920,921c649
< }
< #endif
---
> }
\ No newline at end of file
